#pragma once

#include "main.h"
#include "CCallback.h"
#include "CMySQLHandle.h"
#include "CMySQLQuery.h"
#include "CMySQLResult.h"
//#include "COrm.h"
#include "CLog.h"

#include "misc.h"
#include <cstdio>

#include <chrono>


list<tuple<future<CMySQLQuery>, CMySQLHandle*>> CCallback::m_CallbackQueue;
mutex CCallback::m_QueueMtx;

list<AMX *> CCallback::m_AmxList;



void CCallback::ProcessCallbacks() 
{
	if (!m_CallbackQueue.empty())
	{
		std::lock_guard<mutex> LockGuard(m_QueueMtx);
		auto i = m_CallbackQueue.begin();
		do
		{
			auto &future_res = std::get<0>((*i));

			if (future_res.wait_for(std::chrono::milliseconds(0)) == std::future_status::ready)
			{
				CMySQLQuery QueryObj = std::move(future_res.get()); 
				CMySQLHandle *Handle = std::get<1>(*i);
				bool pass_by_ref = (QueryObj.Callback.Name.find("FJ37DH3JG") != string::npos);

				Handle->DecreaseQueryCounter();
				
				for (auto &amx : m_AmxList)
				{
					int amx_index;

					if (amx_FindPublic(amx, QueryObj.Callback.Name.c_str(), &amx_index) == AMX_ERR_NONE)
					{
						cell amx_mem_addr = -1; 
						CLog::Get()->StartCallback(QueryObj.Callback.Name.c_str());

						while (!QueryObj.Callback.Params.empty())
						{
							boost::variant<cell, string> value = std::move(QueryObj.Callback.Params.top());
							if (value.type() == typeid(cell))
							{
								if (pass_by_ref)
								{
									cell tmp_addr;
									amx_PushArray(amx, &tmp_addr, NULL, (cell*)&boost::get<cell>(value), 1);
									if (amx_mem_addr < NULL)
										amx_mem_addr = tmp_addr;
								}
								else
									amx_Push(amx, boost::get<cell>(value));
							}
							else
							{
								cell tmp_addr;
								amx_PushString(amx, &tmp_addr, NULL, boost::get<string>(value).c_str(), 0, 0);
								if (amx_mem_addr < NULL)
									amx_mem_addr = tmp_addr;
							}

							QueryObj.Callback.Params.pop();
						}

<<<<<<< HEAD
						CMySQLHandle *ConnHandle = std::get<1>(*i);
						ConnHandle->DecreaseQueryCounter();
						ConnHandle->SetActiveResult(QueryObj.Result);
						//QueryObj.Result = NULL;
						CMySQLHandle::ActiveHandle = ConnHandle;
=======
						Handle->SetActiveResult(QueryObj.Result);
						CMySQLHandle::ActiveHandle = Handle;
>>>>>>> 7e00484... code refactoring

						cell amx_ret;
						amx_Exec(amx, &amx_ret, amx_index);
						if (amx_mem_addr >= NULL)
							amx_Release(amx, amx_mem_addr);

						CMySQLHandle::ActiveHandle = NULL;

						if (Handle->IsActiveResultSaved() == false)
							delete Handle->GetActiveResult();

<<<<<<< HEAD
						ConnHandle->SetActiveResult(NULL);
=======
						Handle->SetActiveResult(nullptr);
>>>>>>> 7e00484... code refactoring

						CLog::Get()->EndCallback();

						break; //we have found our callback, exit loop
					}
				}


				i = m_CallbackQueue.erase(i);
			}
			else
			{
				//if(mysql_options.execute-in-order == true)
					//return ;
			}
			
		} while (!m_CallbackQueue.empty() && i != m_CallbackQueue.end() && ++i != m_CallbackQueue.end());
	}
}



void CCallback::AddAmx(AMX *amx) 
{
	m_AmxList.push_back(amx);
}

void CCallback::EraseAmx(AMX *amx) 
{
	for (auto a = m_AmxList.begin(), end = m_AmxList.end(); a != end; ++a)
	{
		if ( (*a) == amx) 
		{
			m_AmxList.erase(a);
			break;
		}
	}
}

void CCallback::ClearAll() 
{
	m_CallbackQueue.clear();
}

void CCallback::FillCallbackParams(stack<boost::variant<cell, string>> &dest, const char *format, AMX* amx, cell* params, const int ConstParamCount)
{
	if (format == NULL || !(*format))
		return ;

	unsigned int ParamIdx = 1;
	cell *AddressPtr = NULL;

	do
	{
		char *StrBuf = NULL;
		switch (*format)
		{
			case 'd':
			case 'i':
			case 'f':
				amx_GetAddr(amx, params[ConstParamCount + ParamIdx], &AddressPtr);
				dest.push(*AddressPtr);
				break;
			case 'z':
			case 's':
				amx_StrParam(amx, params[ConstParamCount + ParamIdx], StrBuf);
				dest.push(StrBuf == NULL ? string() : string(StrBuf));
				break;
			default:
				dest.push(string("NULL"));
		}
		ParamIdx++;
	} while (*(++format));
}
